<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MySQL 5.6 中Binlog Group Commit 实现 | 学而知之</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL 5.6 中Binlog Group Commit 实现</h1><a id="logo" href="/.">学而知之</a><p class="description">生而知之者，上也；学而知之者，次也：困而学之，又其次也；困而不学，民斯为下矣。  -- 孔子</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL 5.6 中Binlog Group Commit 实现</h1><div class="post-meta">2018-08-20<span> | </span><span class="category"><a href="/categories/MySQL/">MySQL</a></span></div><div class="post-content"><h3 id="背景">背景</h3>
<p>在MySQL 5.1中，如果配置项sync_binlog=1，并且innodb_flush_log_at_trx_commit=1，那么MySQL的TPS将会下降到几十每秒，完全不可接受。这是因为InnoDB提交事务时，不仅需要将REDO刷盘，还需要将Binlog刷盘，每个事务都需要2次sync操作。机械磁盘的IOPS也就为几百的水平，所以InnoDB的性能极差。</p>
<p>这个问题，在MySQL 5.6中得到了比较好的解决。在了解Binlog Group Commit之前，需要先了解MySQL Binlog和InnoDB的两阶段提交。MySQL为了保证主库和从库的数据一致性，就必须保证Binlog和InnoDB的一致性，即如果一个事务写入了Binlog，InnoDB中就必须提交该事务；相反，如果一个事务没有写入Binlog，InnoDB就不能提交该事务。做法是：</p>
<p>InnoDB先执行Prepare，将Redo日志写磁盘。然后再将Binlog写磁盘，最后InnoDB再执行Commit，将事务标记为提交。这样，可以保证Binlog和InnoDB的一致性。具体原因，可以分三种情况考虑：</p>
<ol type="1">
<li>果MySQL在InnoDB Prepare阶段Crash。MySQL在启动时做崩溃恢复，InnoDB会回滚这些事务，同时由于事务也没有写到binlog，InnoDB和Binlog一致。</li>
<li>如果MySQL在Binlog写磁盘阶段Crash。MySQL在启动时做崩溃恢复，在恢复时会扫描未成功提交的事务，和当时未成功关闭的binlog文件，如果事务已经Prepare了，并且也已经在Binlog中了，InnoDB会提交该事务；相反，如果事务已经在Prepare中了，但是不在Binlog中，InnoDB会回滚该事务。结果就是InnoDB和Binlog一致。</li>
<li>如果MySQL在InnoDB执行Commit阶段Crash，和情况2类似，由于事务已经成功Prepare，并且存在Binlog文件中，InnoDB在崩溃恢复时，仍然会提交该事务，确保Binlog和InnoDB一致。</li>
</ol>
<p><img src="/images/1436082376.83.2pc.png"> MySQL在实现时，将mysql_bin_log作为2阶段提交的协调者，可以参考MySQL的代码：sql/handler.cc:ha_commit_trans。内部分别调用tc_log-&gt;prepare()和tc_log-&gt;commit()实现2阶段提交，这里的tc_log就是MySQL源码中的全局对象mysql_bin_log。 伪代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ha_commit_trans()</span><br><span class="line">  --&gt; tc_log-&gt;prepare()</span><br><span class="line">        --&gt; ha_prepare_low()</span><br><span class="line">              <span class="keyword">for</span> () &#123;</span><br><span class="line">                ht-&gt;prepare() <span class="comment">//存储引擎 hton-&gt;prepare()</span></span><br><span class="line">              &#125;</span><br><span class="line">  --&gt; tc_log-&gt;commit()</span><br><span class="line">        --&gt; MYSQL_BINLOG::ordered_commit()<span class="comment">//做Group Commit</span></span><br><span class="line">              --&gt; MYSQL_BINLOG::process_commit_stage_queue() <span class="comment">//Group Commit的Commit阶段，会调用InnoDB提交</span></span><br><span class="line">                    --&gt; ha_commit_low()</span><br><span class="line">                          <span class="keyword">for</span> () &#123;</span><br><span class="line">                            ht-&gt;commit(); <span class="comment">//存储引擎 hton-&gt;commit()</span></span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure></p>
<p>两阶段提交的参与者分别为：binlog_hton和innobase_hton，它们实现了MySQL的存储引擎接口。如果你再深入调研一下，就会发现binlog_hton在2阶段提交时，啥也没干。所有binlog操作都是由协调者mysql_bin_log干的，包括Group Commit，也都是在mysql_bin_log中实现的。下面我们就来分析一下，mysql_bin_log是如何做到Group Commit的，也就是上面的函数ordered_commit()。</p>
<h3 id="实现">实现</h3>
<p>和Level DB的Group Commit类似，MySQL的Group Commit也是维护了一个队列，第一个进入队列的线程就是Leader，负责写binlog。其他的线程是Flower，Flower不需要操作，只需要等待完成的通知即可。但是如果只用一个队列的话，在Group Commit进行中的时候，后来的线程就得等待，还可以进一步优化，MySQL把这个过程分裂成了3个阶段：FLUSH_STAGE，SYNC_STAGE和COMMIT_STAGE。它们像流水线一样工作，每个阶段都会涉及一批事务，它们组成一个Group。可以这样理解，事务刚提交时，处于FLUSH阶段，同时处于FLUSH阶段的事务为一个队列，形成一个Group，只有队列的头，Leader在干活，FLUSH完成以后，Leader进入SYNC阶段（所有的Flower也都进入SYNC阶段）。这时，新提交的事务可以进入FLUSH阶段，它们又会产生一个新的Leader，如此不断的推进。每个阶段都需要一个队列，所以MySQL在Group Commit时，需要3个队列。如下图所示，队列通过thd-&gt;next_to_commit连接：</p>
<p><img src="/images/1436082689.4.stage_queue.png"> MySQL把队列命名为Mutex_queue，这是一个C++的类，定义如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex_queue</span> &#123;</span></span><br><span class="line">    THD *m_first; <span class="comment">//队列的头指针</span></span><br><span class="line">    THD **m_last; <span class="comment">//队列尾指针的地址。如果队列为空，相当于&amp;m_first，否则，相当于&amp;last-&gt;next_to_commit</span></span><br><span class="line">    <span class="keyword">mysql_mutex_t</span> m_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在Group Commit时，事务的状态首先转为FLUSH_STAGE，然后为SYNC_STAGE，最后为COMMIT_STAGE。在状态转变时，都会调用如下函数Stage_manager::enroll_for： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stage_manager::enroll_for</span><span class="params">(StageID stage, THD *thd, <span class="keyword">mysql_mutex_t</span> *stage_mutex)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 只有队列的第一个元素为Leader，其他情况均为false</span></span><br><span class="line">  <span class="keyword">bool</span> leader= m_queue[stage].append(thd);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The stage mutex can be NULL if we are enrolling for the first stage.</span></span><br><span class="line">  <span class="keyword">if</span> (stage_mutex)</span><br><span class="line">    mysql_mutex_unlock(stage_mutex);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果不是Leader的话，只需等待Leader完成操作的通知</span></span><br><span class="line"><span class="comment">   * Leader完成以后，会设置thd-&gt;transaction.flags.pending = false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (!leader) &#123;</span><br><span class="line">    mysql_mutex_lock(&amp;m_lock_done);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (thd-&gt;transaction.flags.pending)</span><br><span class="line">      mysql_cond_wait(&amp;m_cond_done, &amp;m_lock_done);</span><br><span class="line"> </span><br><span class="line">    mysql_mutex_unlock(&amp;m_lock_done);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> leader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，Flower线程什么也不干，所有的事情都要靠Leader去做。上述代码有一个细节需要注意，先把自己添加到队列中，然后再释放锁stage_mutex，这个在后面会有解释。下面逐个分析一下，在每个阶段Leader线程所做的事情。</p>
<h3 id="flush阶段">FLUSH阶段</h3>
<p>因为InnoDB在事务执行过程中，要保证事务的原子性。对于INSERT/UPDATE/DELETE操作，会先将Binlog写事务日志（binlog_cache_mngr），事务提交时，也就是在FLUSH阶段，再把事务日志复制到binlog文件中，然后通知Dump线程去发送binlog，由于要写Binlog文件，这个过程需要锁定LOCK_log锁。这也就是FLUSH阶段要做的事情，可参考函数：MYSQL_BIN_LOG::process_flush_stage_queue。</p>
<p>在这个阶段，Leader线程遍历遍历FLUSH_STAGE链表，依次取出thd对应的事务日志，并写到binlog的IOCACHE中，然后flush IOCACHE。代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MYSQL_BIN_LOG::ordered_commit</span><span class="params">(THD *thd, <span class="keyword">bool</span> all, <span class="keyword">bool</span> skip_commit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stage #1: flushing transactions to binary log</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    While flushing, we allow new threads to enter and will process</span></span><br><span class="line"><span class="comment">    them in due time. Once the queue was empty, we cannot reap</span></span><br><span class="line"><span class="comment">    anything more since it is possible that a thread entered and</span></span><br><span class="line"><span class="comment">    appointed itself leader for the flush phase.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (change_stage(thd, Stage_manager::FLUSH_STAGE, thd, <span class="literal">NULL</span>, &amp;LOCK_log))</span><br><span class="line">  &#123;</span><br><span class="line">    DBUG_PRINT(<span class="string">"return"</span>, (<span class="string">"Thread ID: %lu, commit_error: %d"</span>,</span><br><span class="line">                          thd-&gt;thread_id, thd-&gt;commit_error));</span><br><span class="line">    DBUG_RETURN(finish_commit(thd));</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  THD *wait_queue= <span class="literal">NULL</span>;</span><br><span class="line">  flush_error= process_flush_stage_queue(&amp;total_bytes, &amp;do_rotate, &amp;wait_queue);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">my_off_t</span> flush_end_pos= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (flush_error == <span class="number">0</span> &amp;&amp; total_bytes &gt; <span class="number">0</span>)</span><br><span class="line">    flush_error= flush_cache_to_file(&amp;flush_end_pos);</span><br><span class="line">     </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the flush finished successfully, we can call the after_flush</span></span><br><span class="line"><span class="comment">    hook. Being invoked here, we have the guarantee that the hook is</span></span><br><span class="line"><span class="comment">    executed before the before/after_send_hooks on the dump thread</span></span><br><span class="line"><span class="comment">    preventing race conditions among these plug-ins.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (flush_error == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *file_name_ptr= log_file_name + dirname_length(log_file_name);</span><br><span class="line">    DBUG_ASSERT(flush_end_pos != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (RUN_HOOK(binlog_storage, after_flush,</span><br><span class="line">                 (thd, file_name_ptr, flush_end_pos)))</span><br><span class="line">    &#123;</span><br><span class="line">      sql_print_error(<span class="string">"Failed to run 'after_flush' hooks"</span>);</span><br><span class="line">      flush_error= ER_ERROR_ON_WRITE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    signal_update();</span><br><span class="line">    DBUG_EXECUTE_IF(<span class="string">"crash_commit_after_log"</span>, DBUG_SUICIDE(););</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个过程中有一个问题需要考虑，就是：一方面，Leader线程从链表中取出thd，将日志写binlog IOCACHE，另一方面，新提交的事务仍然会往FLUSH_STAGE链表中添加thd。如果MySQL的并发事务比较多，Leader线程写binlog的速度，小于新事务的提交速度，可能会造成事务停留在FLUSH阶段的时间过长。所以MySQL通过配置项binlog_max_flush_queue_time来控制这个时间，如果Leader线程在取THD时，发现超时了，Leader线程就将队列整个端走，再做处理。这样，当前已经处于FLUSH阶段的事务还用现在的Leader，而新提交的事务，会用新的Leader。因为LOCK_log锁的存在，所有新的Leader只能等当前的FLUSH执行完成才能开始执行。具体代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MYSQL_BIN_LOG::process_flush_stage_queue</span><span class="params">(<span class="keyword">my_off_t</span> *total_bytes_var,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">bool</span> *rotate_var,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         THD **out_queue_var)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">bool</span> has_more</span>= <span class="literal">true</span>;</span><br><span class="line">  THD *first_seen= <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> ((max_udelay == <span class="number">0</span> || my_micro_time() &lt; start_utime + max_udelay) &amp;&amp; has_more)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">bool</span>,THD*&gt; current= stage_manager.pop_front(Stage_manager::FLUSH_STAGE);</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">my_off_t</span>&gt; result= flush_thread_caches(current.second);</span><br><span class="line">    has_more= current.first;</span><br><span class="line">    total_bytes+= result.second;</span><br><span class="line">    <span class="keyword">if</span> (flush_error == <span class="number">1</span>)</span><br><span class="line">      flush_error= result.first;</span><br><span class="line">    <span class="keyword">if</span> (first_seen == <span class="literal">NULL</span>)</span><br><span class="line">      first_seen= current.second;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Either the queue is empty, or we ran out of time. If we ran out of</span></span><br><span class="line"><span class="comment">    time, we have to fetch the entire queue (and flush it) since</span></span><br><span class="line"><span class="comment">    otherwise the next batch will not have a leader.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (has_more)</span><br><span class="line">  &#123;</span><br><span class="line">    THD *<span class="built_in">queue</span>= stage_manager.fetch_queue_for(Stage_manager::FLUSH_STAGE);</span><br><span class="line">    <span class="keyword">for</span> (THD *head= <span class="built_in">queue</span> ; head ; head = head-&gt;next_to_commit)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">my_off_t</span>&gt; result= flush_thread_caches(head);</span><br><span class="line">      total_bytes+= result.second;</span><br><span class="line">      <span class="keyword">if</span> (flush_error == <span class="number">1</span>)</span><br><span class="line">        flush_error= result.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first_seen == <span class="literal">NULL</span>)</span><br><span class="line">      first_seen= <span class="built_in">queue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写完binlog IOCACHE后，还要将IOCACHE写文件，最后通知Dump线程读取binlog，FLUSH阶段完成。</p>
<h3 id="syn-c阶段">SYN C阶段</h3>
<p>SYNC阶段的任务比较简单,但是却非常耗时，就是将binlog文件sync到磁盘。这个操作由配置项sync_binlog = N 来控制每隔N个binlog只sync一次。如果sync_binlog=1的话，MySQL在SYNC阶段不释放锁LOCK_log，而Dump线程为了读取binlog，必须先申请锁LOCK_log，所以可以保证主库先将binlog sync到磁盘，然后Dump线程才能读取Binlog，确保即使在主库操作系统Crash情况下，仍然保证主库和从库数据一致。其他情况会释放LOCK_log锁，这时Dump线程可以读取并发送binlog，同时新提交的事务也可以进入FLUSH阶段。所以SYNC阶段需要考虑有多个FLUSH阶段的Leader同时进入SYNC阶段的情况。MySQL将这些Leader合并为一个新的Leader，做法是：FLUSH阶段的Leader线程进入SYNC阶段前，需要将自己加入到SYNC_STAGE队列中，第一个进入SYNC_STAGE队列的线程为SYNC阶段的Leader，后进入的为Flower。由Leader完成后续操作，Flower线程只需等待通知即可。回忆前面的函数enroll_for()，在状态转变时，Leader先把自己添加到SYNC队列中，然后才释放锁stage_mutex，这里就是LOCK_log，其他事务才可以进入FLUSH阶段，这可以保证，第一个进入FLUSH阶段的Leader，在SYNC阶段仍然是Leader，同样，在COMMIT阶段还是Leader。这对于保证Binlog和InnoDB提交顺序一致非常重要。 <img src="/images/1436088683.87.sync_stage.png"> SYNC阶段的代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MYSQL_BIN_LOG::ordered_commit</span><span class="params">(THD *thd, <span class="keyword">bool</span> all, <span class="keyword">bool</span> skip_commit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stage #2: Syncing binary log file to disk</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">bool</span> need_LOCK_log= (get_sync_period() == <span class="number">1</span>); <span class="comment">//只有sync_binlog=1，才不释放LOCK_log锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LOCK_log is not released when sync_binlog is 1. It guarantees that the</span></span><br><span class="line"><span class="comment">    events are not be replicated by dump threads before they are synced to disk.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//不管怎样，都要申请锁LOCK_sync</span></span><br><span class="line">  <span class="keyword">if</span> (change_stage(thd, Stage_manager::SYNC_STAGE, wait_queue,</span><br><span class="line">                   need_LOCK_log ? <span class="literal">NULL</span> : &amp;LOCK_log, &amp;LOCK_sync))</span><br><span class="line">  &#123;</span><br><span class="line">    DBUG_PRINT(<span class="string">"return"</span>, (<span class="string">"Thread ID: %lu, commit_error: %d"</span>,</span><br><span class="line">                          thd-&gt;thread_id, thd-&gt;commit_error));</span><br><span class="line">    DBUG_RETURN(finish_commit(thd));</span><br><span class="line">  &#125;</span><br><span class="line">  THD *final_queue= stage_manager.fetch_queue_for(Stage_manager::SYNC_STAGE);</span><br><span class="line">  <span class="keyword">if</span> (flush_error == <span class="number">0</span> &amp;&amp; total_bytes &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    DEBUG_SYNC(thd, <span class="string">"before_sync_binlog_file"</span>);</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">bool</span>, <span class="keyword">bool</span>&gt; result= sync_binlog_file(<span class="literal">false</span>);</span><br><span class="line">    flush_error= result.first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (need_LOCK_log)</span><br><span class="line">    mysql_mutex_unlock(&amp;LOCK_log);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="commit-阶段">COMMIT 阶段</h3>
<p>经过前面2个阶段，Binlog已经顺利sync到磁盘了，COMMIT阶段的任务就是让InnoDB存储引擎完成Commit。COMMIT阶段的逻辑通过MySQL的配置项binlog_order_commits控制。如果配置项为1，MySQL要保证InnoDB的提交顺序和Binlog的写入顺序一致，这个特性在InnoDB热备中使用。下面只分析binlog_order_commits=1的情况。</p>
<p>MySQL释放锁LOCK_sync，申请锁LOCK_commit。由于释放锁LOCK_sync，所以需要考虑多个线程同时完成SYNC阶段的情况，处理逻辑和SYNC阶段类似，将当前SYNC阶段的Leader合并，关于Leader的产生和SYNC阶段类似。Leader产生以后，遍历THD，完成事务提交，等所有事务都提交完成以后，再遍历thd，设置thd-&gt;transaction.flags.pending=false，最后广播通知Flower线程提交完成，自此，Group Commit完成。</p>
<p>代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MYSQL_BIN_LOG::ordered_commit</span><span class="params">(THD *thd, <span class="keyword">bool</span> all, <span class="keyword">bool</span> skip_commit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Stage #3: Commit all transactions in order.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    This stage is skipped if we do not need to order the commits and</span></span><br><span class="line"><span class="comment">    each thread have to execute the handlerton commit instead.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    Howver, since we are keeping the lock from the previous stage, we</span></span><br><span class="line"><span class="comment">    need to unlock it if we skip the stage.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (opt_binlog_order_commits)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (change_stage(thd, Stage_manager::COMMIT_STAGE,</span><br><span class="line">                     final_queue, &amp;LOCK_sync, &amp;LOCK_commit))</span><br><span class="line">    &#123;</span><br><span class="line">      DBUG_PRINT(<span class="string">"return"</span>, (<span class="string">"Thread ID: %lu, commit_error: %d"</span>,</span><br><span class="line">                            thd-&gt;thread_id, thd-&gt;commit_error));</span><br><span class="line">      DBUG_RETURN(finish_commit(thd));</span><br><span class="line">    &#125;</span><br><span class="line">    THD *commit_queue= stage_manager.fetch_queue_for(Stage_manager::COMMIT_STAGE);</span><br><span class="line">    DBUG_EXECUTE_IF(<span class="string">"semi_sync_3-way_deadlock"</span>,</span><br><span class="line">                    DEBUG_SYNC(thd, <span class="string">"before_process_commit_stage_queue"</span>););</span><br><span class="line">    process_commit_stage_queue(thd, commit_queue);</span><br><span class="line">    mysql_mutex_unlock(&amp;LOCK_commit);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Process after_commit after LOCK_commit is released for avoiding</span></span><br><span class="line"><span class="comment">      3-way deadlock among user thread, rotate thread and dump thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    process_after_commit_stage_queue(thd, commit_queue);</span><br><span class="line">    final_queue= commit_queue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    mysql_mutex_unlock(&amp;LOCK_sync);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* Commit done so signal all waiting threads */</span></span><br><span class="line">  stage_manager.signal_done(final_queue);    </span><br><span class="line">  </span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Leader产生以后，Leader线程通过next_to_commit遍历thd，对每个thd完成事务提交ha_commit_low(),代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">MYSQL_BIN_LOG::process_commit_stage_queue(THD *thd, THD *first)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (THD *head= first ; head ; head = head-&gt;next_to_commit)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;commit_error == THD::CE_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">      excursion.try_to_attach_to(head);</span><br><span class="line">      <span class="keyword">bool</span> all= head-&gt;transaction.flags.real_commit;</span><br><span class="line">      <span class="keyword">if</span> (head-&gt;transaction.flags.commit_low)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* head is parked to have exited append() */</span></span><br><span class="line">        DBUG_ASSERT(head-&gt;transaction.flags.ready_preempt);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          storage engine commit</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (ha_commit_low(head, all, <span class="literal">false</span>))</span><br><span class="line">          head-&gt;commit_error= THD::CE_COMMIT_ERROR;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Decrement the prepared XID counter after storage engine commit.</span></span><br><span class="line"><span class="comment">      We also need decrement the prepared XID when encountering a</span></span><br><span class="line"><span class="comment">      flush error or session attach error for avoiding 3-way deadlock</span></span><br><span class="line"><span class="comment">      among user thread, rotate thread and dump thread.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;transaction.flags.xid_written)</span><br><span class="line">      dec_prep_xids(head);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stage_manager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//遍历THD，标记提交完成，并广播通知</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">signal_done</span><span class="params">(THD *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    mysql_mutex_lock(&amp;m_lock_done);</span><br><span class="line">    <span class="keyword">for</span> (THD *thd= <span class="built_in">queue</span> ; thd ; thd = thd-&gt;next_to_commit)</span><br><span class="line">      thd-&gt;transaction.flags.pending= <span class="literal">false</span>;</span><br><span class="line">    mysql_mutex_unlock(&amp;m_lock_done);</span><br><span class="line">    mysql_cond_broadcast(&amp;m_cond_done);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/blog/1534731278/">MySQL 复制协议</a><a class="next" href="/blog/1534730142/">LevelDB 的 GroupCommit 实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://www.wangyulong.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LevelDB/">LevelDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/1534732562/">编写 MySQL 插件</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534732376/">MySQL 复制中对 Load Data的处理（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534731278/">MySQL 复制协议</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534730601/">MySQL 5.6 中Binlog Group Commit 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534730142/">LevelDB 的 GroupCommit 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534473143/">MySQL 线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534471808/">MySQL 优化器导致暴涨案例分析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534471502/">轻量级网络抓包工具 ngrep</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1533557770/">MySQL GTID 原理以及使用</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1527563667/">Moore NIM 必胜策略</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">学而知之.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>