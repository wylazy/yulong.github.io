<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MySQL 线程模型 | 学而知之</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL 线程模型</h1><a id="logo" href="/.">学而知之</a><p class="description">生而知之者，上也；学而知之者，次也：困而学之，又其次也；困而不学，民斯为下矣。  -- 孔子</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL 线程模型</h1><div class="post-meta">2018-08-17<span> | </span><span class="category"><a href="/categories/MySQL/">MySQL</a></span></div><div class="post-content"><p>MySQL在架构上分为Server层和存储引擎层，它们的线程模型略有不同。在Server层每个连接对应一个线程，几乎没有线程并发控制，只要还可以创建连接，就会创建对应的线程，这些线程之间并发执行。而在InnoDB存储引擎层，为了防止并发线程过多，线程切换开销过大，可以限制并发线程数，从而提高性能。除此以外，MySQL Enterprise版/MariaDB/Percona还提供了在Server层控制并发的方案Thread Pool。本文将分别对他们进行介绍。</p>
<h3 id="server层线程模型">Server层线程模型</h3>
<p>MySQL的工作模式是为每个连接分配一个线程，当客户端和MySQL服务器建立TCP连接之后，MySQL服务器就会给这个连接分配一个线程，当这个连接收到SQL时，对应的线程就执行这个SQL，而当SQL执行结束后，这个线程就去Sleep，等待客户端的新请求。这个线程会一直存活，直到客户端退出登录，并关闭连接，这个线程才会退出（或者进入MySQL的ThreadCache）。示意图如下图所示： <img src="1475135372.75.thread_model.png"> 接收新连接和创建线程的如下文所示，（相关代码在sql/mysqld.cc中） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!abort_loop)</span><br><span class="line">&#123;</span><br><span class="line">  retval= poll(fds, socket_count, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; socket_count; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[i].revents &amp; POLLIN)</span><br><span class="line">    &#123;</span><br><span class="line">      sock= pfs_fds[i]; <span class="comment">//获取对应sock，可能是Unix套接字，或者是TCP/IP套接字</span></span><br><span class="line">      flags= fcntl(mysql_socket_getfd(sock), F_GETFL, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// Accept新连接</span></span><br><span class="line">  new_sock= mysql_socket_accept(key_socket_client_connection, sock,</span><br><span class="line">                                  (struct sockaddr *)(&amp;cAddr), &amp;length);</span><br><span class="line">                                   </span><br><span class="line">  thd= <span class="keyword">new</span> THD; <span class="comment">//为连接分配内存对象，THD只是一个普通的C++ Class，是线程处理请求的参数</span></span><br><span class="line">   </span><br><span class="line">  create_new_thread(thd); <span class="comment">//创建新线程？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码可以看到，MySQL的主线程没有什么复杂的逻辑，就是通过系统调用poll()不断接收新连接，每当接收到一个新连接，就创建一个新的线程去处理这个连接的请求。</p>
<h3 id="thread-cache">Thread Cache</h3>
<p>上面这段代码好像任何学过网络编程的初学者都可以写出来，但是MySQL为了提高性能又额外添了点儿东西，叫作ThreadCache，通过set global thread_cache_size=xxx可以设置ThreadCache的大小。这个ThreadCache不同于传统意义上的线程池，ThreadCache并没有改变TCP连接和线程之间一对一的关系。我们知道操作系统创建线程是有一定开销的，ThreadCache则是为了减少创建线程的开销而设立的。</p>
<p>上述代码中create_new_thread(thd)的命名非常具有迷惑性，因为它并不一定真的会创建新线程，也有可能只是把thd交给别的线程，委托另外一个线程去处理这个连接请求。最终创建线程相关代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create_new_thread最终会调用create_thread_to_handle_connection处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_thread_to_handle_connection</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mysql_mutex_assert_owner(&amp;LOCK_thread_count);</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span> (blocked_pthread_count &gt;  wake_pthread) <span class="comment">//说明ThreadCache中还有空闲线程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Wake up blocked pthread */</span></span><br><span class="line">    waiting_thd_list-&gt;push_back(thd); <span class="comment">//将thd放到队列，并通知线程拿走thd</span></span><br><span class="line">    wake_pthread++;</span><br><span class="line">    mysql_cond_signal(&amp;COND_thread_cache);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 没有空闲线程了，创建新线程</span></span><br><span class="line">  &#123;</span><br><span class="line">    mysql_thread_create(key_thread_one_connection,</span><br><span class="line">                        &amp;thd-&gt;real_id, &amp;connection_attrib,</span><br><span class="line">                        handle_one_connection, <span class="comment">// 新线程入口函数为handle_one_connection</span></span><br><span class="line">                        (<span class="keyword">void</span>*) thd)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  mysql_mutex_unlock(&amp;LOCK_thread_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面代码可以看到，如果还有空闲线程，MySQL就会把thd放到队列waiting_thd_list中，等待其他线程拿走thd，并作处理。为了了解ThreadCache的工作原理，就必须继续探究这些空闲线程是哪儿来的？为了回答这个问题，我们得从线程入口函数handle_one_connection() 开始了解，简化后相关代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle_one_connection最终会调用do_handle_one_connection处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_handle_one_connection</span><span class="params">(THD *thd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 通过循环处理这个连接上的请求，直到连接被关闭</span></span><br><span class="line">    <span class="keyword">while</span> (thd_is_connection_alive(thd)) <span class="comment">//连接没有关闭</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (do_command(thd)) <span class="comment">//在网络上等待，接收并处理一条SQL</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 当上一个连接的请求全都被处理完时，在条件变量COND_thread_cache上等待</span></span><br><span class="line">    <span class="keyword">if</span> (blocked_pthread_count &lt; max_blocked_pthreads &amp;&amp;</span><br><span class="line">      !abort_loop &amp;&amp; !kill_blocked_pthreads_flag)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Block pthread</span></span><br><span class="line">      <span class="keyword">while</span> (!abort_loop &amp;&amp; !wake_pthread &amp;&amp; !kill_blocked_pthreads_flag)</span><br><span class="line">        mysql_cond_wait(&amp;COND_thread_cache, &amp;LOCK_thread_count);</span><br><span class="line">      thd= waiting_thd_list-&gt;front(); <span class="comment">// 从队列中取出第一个元素</span></span><br><span class="line">      waiting_thd_list-&gt;pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码可以看到，当MySQL新创建的线程处理完请求之后（连接被关闭），这个线程并不会退出，而是在条件变量COND_thread_cache上等待，当被唤醒以后，就从waiting_thd_list上获取第一个thd继续处理。</p>
<p>以上就是ThreadCache的逻辑，通过代码可以看到并不存在一个像内存之类的Cache把线程都缓存起来，等需要时再把线程从Cache中取出。MySQL需要的是一个条件变量COND_pthread_cache，和一个队列waiting_thd_list。当服务完一个连接之后，空闲的线程并不会退出，而是在条件变量上等待，而waiting_thd_list队列里放的是线程所需要的参数。当新的TCP连接建立时，主线程会先尝试把thd放到队列里，如果可以的话，然后主线程只需要在条件变量上signal一次即可，然后空闲的线程就会从队列中把thd拿走，并为这个连接服务。只有没有空闲线程时，MySQL才需要创建新线程。</p>
<h3 id="innodb-线程模型">InnoDB 线程模型</h3>
<p>通过前面的叙述可以我们知道，MySQL在Server层根本就没有对并发线程的数量进行控制，当MySQL的并发连接数增加时，就会导致对应的线程数量增加。这样可能把机器的大量CPU资源都耗费在线程切换上了，导致性能急剧下降。InnoDB为了缓解这种情况，通过设置系统变量set global innodb_thread_concurrency ＝ x可以控制内部并发线程的数量，也就是最多允许innodb_thread_concurrency个线程同时在InnoDB内部运行。也就是说在Server层可以创建很多线程，但是到了InnoDB内部，只会有少量线程并发执行，其他线程都处于sleep状态。示意图如下： <img src="/images/1478248924.87.thread_model_innodb.png"> 这种模型在InnoDB里是怎么实现的呢？熟悉MySQL代码的同学应该都知道，InnoDB通过ha_innobase::write_row(), ha_innobase::update_row(), ha_innobase::delete_row(), ha_innobase::index_read(), ha_innobase::general_fetch()等接口操作数据，一个接口只操作一行数据。InnoDB在这些接口中进行并发控制。拿write_row()举例来说，相应代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ha_innobase::write_row</span><span class="params">(uchar*  record)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    innobase_srv_conc_enter_innodb(prebuilt-&gt;trx); <span class="comment">// 操作数据前，先控制并发</span></span><br><span class="line">    error = row_insert_for_mysql((byte*) record, prebuilt); <span class="comment">// 操作数据</span></span><br><span class="line">    innobase_srv_conc_exit_innodb(prebuilt-&gt;trx);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>InnoDB通过调用函数innobase_srv_conc_enter_innodb()来控制并发，只有当InnoDB内部并发数小于限制值，才允许进行后续操作，否则就等待。我们知道一个存储引擎API只能操作一行数据，那么如果一条SQL修改很多条纪录呢，那就需要调用很多次InnoDB的API，如果对每行数据操作都要进行并发控制，那么对性能还是有一定影响的。InnoDB想了一个办法是，一旦线程进入InnoDB内核，就给他n个tickets，意思是它后续可以进行n次操作，不需要重新申请进入InnoDB内核，当这n个tickets用完之后，如果它还想进入InnoDB内核，那么对不起，请重新获取tickets（当然还是n个tickets）。每次获取tickets的数量对应的InnoDB变量是innodb_concurrency_tickets，可以动态调整。在MySQL 5.5以及之前，innodb_concurrency_tickets的默认值是500，从5.6开始默认值是5000。相应代码如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">innobase_srv_conc_enter_innodb</span><span class="params">(<span class="keyword">trx_t</span> * trx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srv_thread_concurrency) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (trx-&gt;n_tickets_to_enter_innodb &gt; <span class="number">0</span>) &#123; <span class="comment">// 线程已有tickets</span></span><br><span class="line">            --trx-&gt;n_tickets_to_enter_innodb;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 线程没有tickets</span></span><br><span class="line">            srv_conc_enter_innodb(trx);  <span class="comment">// 申请tickets</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上述代码很明显可以看到，一旦线程拿到了tickets，并发控制时就只是消耗一个tickets而已，其它的什么也不用干，代价非常低。如果没有tickets或者tickets已经用完了，就需要申请tickets了。申请tickets时，InnoDB支持两种方式，一种方式时当gcc不支持原子操作时，InnoDB使用mutex和cond实现tickets的申请；另外一种方式是当gcc支持原子操作时，InnoDB使用无锁方式申请tickets。现代机器体系结构以及gcc都支持了原子操作，所以一般使用无锁方式比较多。但是这里有一个问题：申请InnoDB的tickets是做并发控制用的，如果并发数超出限制了，InnoDB就不能分配tickets，而是要让当前线程等待，既然是使用无锁方式分配tickets，那么线程怎么等呢？答案在以下代码中： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// srv_conc_enter_innodb 会调用此函数申请tickets</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srv_conc_enter_innodb_with_atomics</span><span class="params">(<span class="keyword">trx_t</span> * trx)</span> </span>&#123; <span class="comment">// 无锁方式申请tickets</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// srv_conc.n_active是当前已经进入InnoDB内核的线程数，srv_thread_concurrency是并发上限</span></span><br><span class="line">        <span class="keyword">if</span> (srv_conc.n_active &lt; (lint) srv_thread_concurrency) &#123;</span><br><span class="line">            n_active = os_atomic_increment_lint(&amp;srv_conc.n_active, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (n_active &lt;= srv_thread_concurrency) &#123; <span class="comment">// 如果并发没有超</span></span><br><span class="line">                srv_enter_innodb_with_tickets(trx); <span class="comment">// 分配tickets</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            (<span class="keyword">void</span>) os_atomic_decrement_lint(&amp;srv_conc.n_active, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        os_thread_sleep(srv_thread_sleep_delay); <span class="comment">// 通过sleep释放CPU资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>InnoDB申请tickets时用了一个大的循环，不停的尝试获取tickets，如果并发没有超限，就给当前线程n个tickets，否则就sleep一段时间，然后再尝试。这个sleep的时间默认是innodb_thread_sleep_delay，单位是微秒。而且这个值会动态调整，通过while循环尝试的次数越多，这个值就越大。InnoDB通过无锁方式获取tickets其实就是通过while循环不停的尝试，这个倒是有点儿让我意外，这个性能真的会比mutex和cond的性能好吗？也许吧，这个有时间测试下。而退出InnoDB内核的方法也很简单，用原子操作直接将srv_conc.n_active减1就可以了，代码比较简单，这里就不贴了。</p>
<p>除此以外，还有一个问题需要考虑：我们知道InnoDB使用行锁进行事务并发控制，如果一个进入InnoDB的事务需要等另外一个事务释放锁，这个时候该怎么办，要让当前线程退出InnoDB内核吗？是需要的，因为如果不退出可能产生死锁：为了简单起见，我们假设innodb_thread_concurrency的值是1，trx1进入InnoDB内核，trx2由于由于InnoDB并发数量的限制拿不到tickets，就无法往下执行。然后trx1修改数据，如果很不幸需要等trx2释放锁，那么trx1和trx2就会相互等待。所以在事务需要等锁时，必须先从InnoDB内核中出来再等锁，当拿到锁之后，再重新进入InnoDB内核。这一方面可以提高并发性，另一方面避免了死锁。InnoDB事务在等锁时，会调用函数lock_wait_suspend_thread()，其内部实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_wait_suspend_thread</span><span class="params">(<span class="keyword">que_thr_t</span>*  thr)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    was_declared_inside_innodb = trx-&gt;declared_to_be_inside_innodb;</span><br><span class="line">    <span class="keyword">if</span> (was_declared_inside_innodb) &#123;</span><br><span class="line">        srv_conc_force_exit_innodb(trx); <span class="comment">// 先退出InnoDB内核</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    os_event_wait(slot-&gt;event); <span class="comment">// 事务等锁</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (was_declared_inside_innodb) &#123;</span><br><span class="line">        srv_conc_force_enter_innodb(trx); <span class="comment">// 重新进入InnoDB内核，只能拿到一个ticket</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的总结，我们可以看到InnoDB对线程并发的控制粒度是非常细的，所有进入InnoDB内核的线程都是在进行CPU操作，当需要等锁时，线程会退出InnoDB内核，允许其他线程进入InnoDB，InnoDB的并发数控制策略可以保持CPU总是处于工作状态。但是在Server层，如果连接数很高（连接数超过2千），仍然会占用大量的线程，线程切换开销不可忽视，造成性能下降。为了解决这个问题，还需要更加彻底的方案。</p>
<h3 id="thread-pool">Thread Pool</h3>
<p>Thread Pool在MySQL官方是以Enterprise版plugin的形式出现的，而在MariaDB和Percona都是侵入MySQL源码的，它们在实现上大同小异，并没有本质区别。这里主要分析Percona的Thread Pool实现。如前文所述，MySQL Server在每当有一个客户端连接进来时，都会创建一个线程来服务这个连接。而Thread Pool的思想是将连接和线程解绑，连接和线程之间不再是一对一的关系，而是m对n的关系。具体做法是通过epoll监听网络端口，一旦有客户端数据需要处理，就把这个连接放入队列，让后台线程池从队列中取出连接信息，并服务这个连接。也就是说MySQL的连接数可以非常高，但是线程数量可以只有几十个。通过Thread Pool彻底解决线程数量过多，导致性能下降的问题，示意图如下： <img src="/images/1478250497.6.thread_model_thread_pool.png"> 下面将通过源码来分析Percona 线程池的实现（Percona的线程池同时支持Linux和Windows，本文只分析Linux下的实现）。MySQL为服务连接预留了接口，定义如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: sql/scheduler.h</span></span><br><span class="line"><span class="comment">/* Functions used when manipulating threads */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scheduler_functions</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  uint max_threads;</span><br><span class="line">  <span class="keyword">bool</span> (*init)(<span class="keyword">void</span>);</span><br><span class="line">  <span class="keyword">bool</span> (*init_new_connection_thread)(<span class="keyword">void</span>);</span><br><span class="line">  <span class="keyword">void</span> (*add_connection)(THD *thd); <span class="comment">// 当新连接到来时，会回调此函数</span></span><br><span class="line">  <span class="keyword">void</span> (*thd_wait_begin)(THD *thd, <span class="keyword">int</span> wait_type);</span><br><span class="line">  <span class="keyword">void</span> (*thd_wait_end)(THD *thd);</span><br><span class="line">  <span class="keyword">void</span> (*post_kill_notification)(THD *thd);</span><br><span class="line">  <span class="keyword">bool</span> (*end_thread)(THD *thd, <span class="keyword">bool</span> cache_thread);</span><br><span class="line">  <span class="keyword">void</span> (*end)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接口通过配置项thread_handling来初始化对应的回调 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: sql/mysqld.cc</span></span><br><span class="line">  <span class="keyword">if</span> (thread_handling &lt;= SCHEDULER_ONE_THREAD_PER_CONNECTION) <span class="comment">// 默认配置</span></span><br><span class="line">    one_thread_per_connection_scheduler(thread_scheduler, &amp;max_connections,</span><br><span class="line">                                        &amp;connection_count);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (thread_handling == SCHEDULER_NO_THREADS)</span><br><span class="line">    one_thread_scheduler(thread_scheduler);</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 配置为线程池</span></span><br><span class="line">    pool_of_threads_scheduler(thread_scheduler,  &amp;max_connections,</span><br><span class="line">                                        &amp;connection_count);</span><br><span class="line">                                         </span><br><span class="line"><span class="comment">// file: sql/thread_common.cc</span></span><br><span class="line"><span class="comment">// 线程池的回调实现</span></span><br><span class="line"><span class="keyword">static</span> scheduler_functions tp_scheduler_functions=</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// max_threads</span></span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  <span class="literal">NULL</span>,</span><br><span class="line">  tp_init,                            <span class="comment">// init</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// init_new_connection_thread</span></span><br><span class="line">  tp_add_connection,                  <span class="comment">// add_connection</span></span><br><span class="line">  tp_wait_begin,                      <span class="comment">// thd_wait_begin</span></span><br><span class="line">  tp_wait_end,                        <span class="comment">// thd_wait_end</span></span><br><span class="line">  tp_post_kill_notification,          <span class="comment">// post_kill_notification</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// end_thread</span></span><br><span class="line">  tp_end                              <span class="comment">// end</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pool_of_threads_scheduler</span><span class="params">(struct scheduler_functions *func,</span></span></span><br><span class="line"><span class="function"><span class="params">    ulong *arg_max_connections,</span></span></span><br><span class="line"><span class="function"><span class="params">    uint *arg_connection_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *func = tp_scheduler_functions; <span class="comment">// 将接口初始化为线程池实现</span></span><br><span class="line">  func-&gt;max_threads= threadpool_max_threads;</span><br><span class="line">  func-&gt;max_connections= arg_max_connections;</span><br><span class="line">  func-&gt;connection_count= arg_connection_count;</span><br><span class="line">  scheduler_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当新连接到来时，mysql会掉用tp_add_connection()函数来处理该请求，其源码实现并没有什么magic，内部使用了2个队列，一个优先级高，另一个优先级低。当epoll认为有数据到来时，会把连接放入队列中，后台线程从队列中取出连接，服务该请求。</p>
<p>这里有2个问题需要注意，一个是Percona实现的线程池是非常粗粒度的，当客户端发送SQL到MySQL Server时，如果是在内部等锁，并不会释放CPU执行权，只有等网络才会释放CPU执行权。也就是说SQL在InnoDB内部等锁，仍然会占用线程池的一个线程，可能导致其他请求不能执行。另外Dump线程在等待binlog更新时，也会占用线程池的一个线程，如果从库数量过多，对线程池的性能会产生一定影响。</p>
<p>另一个问题是如果线程池全部忙碌，会阻止新连接的建立，表现出来的现象是无法登录mysql server（即使是dba也无法登录）。Percona采用的方案是用一个额外的端口来解决这个问题，通过extra_port来配置端口，通过此端口进来的连接，仍然是每个连接对应一个线程。</p>
</div><div class="tags"><a href="/tags/MySQL/"><i class="fa fa-tag"></i>MySQL</a></div><div class="post-nav"><a class="pre" href="/blog/1534730142/">LevelDB 的 GroupCommit 实现</a><a class="next" href="/blog/1534471808/">MySQL 优化器导致暴涨案例分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://www.xuerzhi.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LevelDB/">LevelDB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/1534732562/">编写 MySQL 插件</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534732376/">MySQL 复制中对 Load Data的处理（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534731278/">MySQL 复制协议</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534730601/">MySQL 5.6 中Binlog Group Commit 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534730142/">LevelDB 的 GroupCommit 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534473143/">MySQL 线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534471808/">MySQL 优化器导致暴涨案例分析</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1534471502/">轻量级网络抓包工具 ngrep</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1533557770/">MySQL GTID 原理以及使用</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/1527563667/">Moore NIM 必胜策略</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">学而知之.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>